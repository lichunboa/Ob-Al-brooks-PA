# Plugin Smart Optimization Skill

> **目标**: 使用 MCP 工具生态安全、渐进式地优化和重构 Obsidian 插件代码  
> **版本**: v1.0.0  
> **创建**: 2026-01-07  
> **维护**: 持续更新

---

## 📁 如何部署到 .claude/skills

这个技能文档需要复制到 `.claude/skills/plugin-smart-optimization/` 目录才能被 Claude 自动加载。

### 目录结构

```
/Users/mitchellcb/.claude/skills/plugin-smart-optimization/
├── SKILL.md                           # 主技能文档(本文件)
├── memory/
│   └── optimization_lessons.md        # 优化经验库(必读/必写)
└── references/
    ├── optimization_patterns.md       # 优化模式库
    ├── gotchas.md                     # 常见陷阱
    ├── changelog.md                   # 变更记录
    └── checklists.md                  # 检查清单
```

### 部署步骤

```bash
# 1. 创建目录结构
mkdir -p /Users/mitchellcb/.claude/skills/plugin-smart-optimization/{memory,references}

# 2. 复制本文件为 SKILL.md
cp "🧠 插件智能优化技能.md" /Users/mitchellcb/.claude/skills/plugin-smart-optimization/SKILL.md

# 3. 创建子文件(见下方模板)
```

---

## 📋 技能概述

这是一个基于 MCP 工具生态的智能代码优化技能,用于安全、渐进式地优化和重构 Obsidian 插件代码。

**核心理念**:
- 🧠 **智能分析** - 使用 AI 工具深度理解代码,而非机械化分析
- 🛡️ **安全优先** - 每一步都可回滚,绝不破坏现有功能
- 📈 **渐进式** - 小步快跑,持续改进
- 💾 **经验积累** - 记录每次优化,建立知识图谱

---

## 🛠️ 工具生态

### 核心工具

| 工具 | 用途 | 使用场景 |
|------|------|----------|
| **sequential-thinking** | 深度分析和推理 | 分析复杂问题、评估风险、设计方案 |
| **serena** | 代码语义理解 | 分析代码结构、识别重复模式、理解依赖关系 |
| **context7** | 最佳实践查询 | 查询官方文档、框架最佳实践、版本特定实现 |
| **morphllm** | 模式化重构 | 批量代码转换、统一代码风格、自动化重构 |
| **neo4j-memory** | 经验沉淀 | 记录优化决策、建立知识图谱、避免重复犯错 |

### 辅助工具

| 工具 | 用途 |
|------|------|
| **git** | 版本控制、分支管理、回滚 |
| **npm** | 构建测试、依赖管理 |

---

## 🎯 标准优化流程

### 流程图

```
┌─────────────────────────────────────────────────────────┐
│                    优化任务开始                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 1. 思考 (sequential-thinking)                            │
│    - 分析要优化的代码                                     │
│    - 评估风险和影响范围                                   │
│    - 设计优化方案                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. 分析 (serena)                                         │
│    - 理解代码结构和依赖关系                               │
│    - 识别重复代码模式                                     │
│    - 分析模块耦合度                                       │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 3. 查询 (context7)                                       │
│    - 查询官方最佳实践                                     │
│    - 确认实现方式                                         │
│    - 避免常见陷阱                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 4. 创建安全点                                            │
│    - git checkout -b backup-$(date)                     │
│    - 记录当前状态                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 5. 重构 (morphllm)                                       │
│    - 批量代码转换                                         │
│    - 保持代码一致性                                       │
│    - 减少手工错误                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 6. 验证                                                  │
│    - npm run build (构建测试)                            │
│    - 手动功能测试                                         │
│    - 性能测试(如需要)                                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
                 验证通过?
                     │
        ┌────────────┴────────────┐
        │                         │
       是                         否
        │                         │
        ▼                         ▼
┌───────────────┐        ┌─────────────────┐
│ 7. 提交变更    │        │ 8. 回滚并分析    │
│ - git commit  │        │ - git reset     │
│ - 记录成功    │        │ - 分析失败原因   │
└───────┬───────┘        └────────┬────────┘
        │                         │
        │                         │
        └────────────┬────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 9. 记录 (neo4j-memory)                                   │
│    - 记录优化内容和原因                                   │
│    - 记录经验教训                                         │
│    - 更新知识图谱                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    优化任务完成                          │
└─────────────────────────────────────────────────────────┘
```

---

## 📖 详细步骤说明

### 步骤 1: 思考 (sequential-thinking)

**目标**: 深度理解问题,设计安全的优化方案

**操作**:
```markdown
使用 sequential-thinking 分析:

1. **问题定义**
   - 当前代码有什么问题?
   - 为什么需要优化?
   - 优化的目标是什么?

2. **影响范围分析**
   - 哪些模块会受影响?
   - 有哪些依赖关系?
   - 可能的副作用是什么?

3. **风险评估**
   - 风险等级: 低/中/高
   - 失败的可能性
   - 回滚的难度

4. **方案设计**
   - 优化的具体步骤
   - 每一步的验证方式
   - 备选方案
```

**输出**: 优化方案文档

---

### 步骤 2: 分析 (serena)

**目标**: 语义级别理解代码结构

**操作**:
```bash
# 1. 激活 serena 项目环境
mcp__serena__activate_project

# 2. 分析代码符号和引用
# 使用 serena 的代码理解能力

# 3. 识别重复代码模式
# 4. 分析模块依赖关系
```

**输出**: 
- 函数调用图
- 重复代码列表
- 依赖关系图

---

### 步骤 3: 查询 (context7)

**目标**: 确保使用官方推荐的最佳实践

**操作**:
```markdown
使用 context7 查询:

1. **框架最佳实践**
   - React Hooks 使用规范
   - TypeScript 类型优化
   - Obsidian 插件 API 最佳实践

2. **性能优化技巧**
   - 组件优化
   - 状态管理
   - 渲染优化

3. **常见陷阱**
   - 避免的反模式
   - 已知问题
```

**输出**: 最佳实践文档

---

### 步骤 4: 创建安全点

**目标**: 确保可以随时回滚

**操作**:
```bash
# 创建备份分支
git checkout -b backup-$(date +%Y%m%d-%H%M%S)

# 切换回工作分支
git checkout feature/smart-optimization

# 记录当前状态
git log -1 --oneline
```

---

### 步骤 5: 重构 (morphllm)

**目标**: 批量、一致地进行代码转换

**操作**:
```markdown
使用 morphllm 进行:

1. **批量重命名**
   - 统一命名规范
   - 保持一致性

2. **代码提取**
   - 提取重复逻辑
   - 创建公共函数

3. **模式转换**
   - 统一代码风格
   - 应用最佳实践
```

---

### 步骤 6: 验证

**目标**: 确保优化没有破坏功能

**操作**:
```bash
# 1. 构建测试
npm run build

# 2. 类型检查
npm run type-check

# 3. 代码规范检查
npm run lint
```

**手动测试清单**:
- [ ] Trading Hub 显示正常
- [ ] Analytics 图表正常
- [ ] Learn 推荐正常
- [ ] Manage 功能正常
- [ ] 创建交易笔记正常
- [ ] 数据统计正确

---

### 步骤 7: 提交变更

**目标**: 记录成功的优化

**操作**:
```bash
# 提交变更
git add .
git commit -m "refactor: [描述优化内容]

- 优化内容 1
- 优化内容 2
- 优化内容 3

风险等级: 低
验证: 构建通过 + 功能测试通过"
```

---

### 步骤 8: 回滚并分析

**目标**: 从失败中学习

**操作**:
```bash
# 立即回滚
git reset --hard HEAD~1

# 或切换到备份分支
git checkout backup-20260107-161500
```

**失败分析**:
```markdown
使用 sequential-thinking 分析:

1. **失败原因**
   - 技术原因
   - 设计缺陷
   - 遗漏的依赖

2. **经验教训**
   - 下次如何避免
   - 需要补充的知识

3. **改进方案**
   - 调整优化策略
   - 增加验证步骤
```

---

### 步骤 9: 记录 (neo4j-memory)

**目标**: 积累优化经验,建立知识图谱

**操作**:
```markdown
使用 neo4j-memory 记录:

1. **优化记录**
   - 优化内容: [描述]
   - 优化原因: [原因]
   - 风险等级: 低/中/高
   - 结果: 成功/失败
   - 耗时: [时间]

2. **经验教训**
   - 成功经验: [描述]
   - 失败教训: [描述]
   - 最佳实践: [描述]

3. **知识关联**
   - 相关优化: [链接]
   - 相关文档: [链接]
   - 相关问题: [链接]
```

---

## 🎓 常见优化场景

### 场景 1: 提取纯函数

**适用情况**: 组件中有大量计算逻辑

**风险等级**: 🟢 低

**步骤**:
1. 使用 serena 识别纯函数
2. 使用 sequential-thinking 评估提取风险
3. 创建 `src/utils/` 目录
4. 使用 morphllm 批量提取
5. 验证功能
6. 记录到 neo4j-memory

**示例**:
```typescript
// 提取前: Dashboard.tsx
const winRate = trades.filter(t => t.outcome === 'win').length / trades.length;

// 提取后: src/utils/trade-calculations.ts
export function calculateWinRate(trades: Trade[]): number {
  if (trades.length === 0) return 0;
  return trades.filter(t => t.outcome === 'win').length / trades.length;
}
```

---

### 场景 2: 提取自定义 Hooks

**适用情况**: 组件中有复杂的状态管理和副作用

**风险等级**: 🟡 中

**步骤**:
1. 使用 context7 查询 React Hooks 最佳实践
2. 使用 sequential-thinking 设计 Hook 接口
3. 创建 `src/hooks/` 目录
4. 逐个提取数据加载逻辑
5. 每个 Hook 独立测试
6. 记录到 neo4j-memory

**示例**:
```typescript
// 提取前: Dashboard.tsx
useEffect(() => {
  const loadData = async () => {
    const trades = await tradeIndex.getAllTrades();
    setTrades(trades);
  };
  loadData();
}, []);

// 提取后: src/hooks/useDashboardData.ts
export function useDashboardData() {
  const [trades, setTrades] = useState<Trade[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const trades = await tradeIndex.getAllTrades();
      setTrades(trades);
      setLoading(false);
    };
    loadData();
  }, []);
  
  return { trades, loading };
}
```

---

### 场景 3: 拆分大型组件

**适用情况**: 组件超过 1000 行

**风险等级**: 🔴 高

**前置评估** (必须先做!):
1. **代码量分析**: 统计各部分的行数
   - 超过2000行: 极高风险,建议先精简
   - 1000-2000行: 高风险,需要详细规划
   - 500-1000行: 中等风险,可以尝试
   - 小于500行: 低风险

2. **耦合度分析**: 评估代码依赖关系
   - Props数量: 超过20个表示高度耦合
   - 共享状态: 多个部分共享状态增加难度
   - 事件处理: 分散的事件处理器难以整理

3. **类型依赖**: 检查类型导入和导出
   - 未导出的类型会导致编译错误
   - 需要提前整理类型定义

**渐进式方法** (推荐):
1. **先精简再拆分**:
   - 提取纯函数到utils (减少500-800行)
   - 优化Hooks (减少200-300行)
   - 提取小型组件 (减少300-500行)
   - 等组件精简到合理大小后再拆分

2. **小步拆分**:
   - 从最小的、耦合最少的部分开始
   - 每次拆分后立即测试
   - 保持可回滚

**直接拆分步骤** (仅用于低耦合组件):
1. 使用 serena 分析组件边界
2. 使用 sequential-thinking 设计拆分方案
3. 使用 context7 查询组件拆分最佳实践
4. 创建子组件目录
5. 逐个拆分,每次拆分后立即测试
6. 记录到 neo4j-memory

**注意事项**:
- ⚠️ 超过1000行的代码块很难一次性拆分
- ⚠️ 每次只拆分一个子组件
- ⚠️ 保持 Props 接口清晰 (建议少于15个)
- ⚠️ 避免过度拆分
- ⚠️ 遇到困难及时调整策略,不要硬推
- ⚠️ 保持项目清洁,删除临时文件

---

### 场景 4: 移除重复代码

**适用情况**: 发现多处相同或相似的代码

**风险等级**: 🟡 中

**步骤**:
1. 使用 serena 识别重复代码模式
2. 使用 sequential-thinking 评估合并风险
3. 提取为公共函数或组件
4. 使用 morphllm 批量替换
5. 验证所有使用场景
6. 记录到 neo4j-memory

---

## 📊 优化指标

### 代码质量指标

| 指标 | 目标 | 当前 | 备注 |
|------|------|------|------|
| Dashboard.tsx 行数 | < 5000 | 7624 | 需要拆分 |
| 平均函数长度 | < 50 行 | - | 待测量 |
| 重复代码率 | < 5% | - | 待测量 |
| 循环依赖数 | 0 | - | 待测量 |

### 性能指标

| 指标 | 目标 | 当前 | 备注 |
|------|------|------|------|
| 构建时间 | < 10s | - | 待测量 |
| 插件加载时间 | < 1s | - | 待测量 |
| 内存占用 | < 50MB | - | 待测量 |

---

## 🛡️ 风险控制清单

### 优化前检查

- [ ] 已创建 LTS 标签
- [ ] 已创建备份分支
- [ ] 已使用 sequential-thinking 评估风险
- [ ] 已使用 serena 分析影响范围
- [ ] 已查询相关最佳实践

### 优化中检查

- [ ] 每次修改后立即构建测试
- [ ] 保持小步快跑
- [ ] 遇到问题立即停止
- [ ] 记录每一步的变更

### 优化后检查

- [ ] 构建测试通过
- [ ] 功能测试通过
- [ ] 性能没有退化
- [ ] 已记录到 neo4j-memory
- [ ] 已更新文档

---

## 📚 经验库

### 成功经验

#### 经验 1: 纯函数提取是最安全的重构方式
- **日期**: 2026-01-07
- **场景**: 提取计算逻辑
- **风险**: 低
- **结果**: 成功
- **教训**: 纯函数没有副作用,提取后容易测试和维护

#### 经验 2: 大型组件拆分需要谨慎
- **日期**: 2026-01-06
- **场景**: 拆分 Dashboard.tsx
- **风险**: 高
- **结果**: 部分成功,部分失败
- **教训**: 不要一次性拆分太多,每次只拆分一个 Tab

#### 经验 3: 代码量评估是拆分前的必要步骤
- **日期**: 2026-01-08
- **场景**: 阶段5 Tab拆分尝试
- **风险**: 中
- **结果**: 成功识别风险并调整策略
- **教训**: 
  - 超过1000行的代码块很难一次性拆分
  - 需要先评估代码耦合度和依赖关系
  - Tab代码量: Trading 836行, Analytics 1362行, Learn 1170行, Manage 2086行
  - 即使最小的Tab也需要30+个Props传递

#### 经验 4: 渐进式精简优于直接拆分
- **日期**: 2026-01-08
- **场景**: Tab拆分策略调整
- **风险**: 低
- **结果**: 制定了更合理的优化路径
- **教训**:
  - 先提取纯函数(预计减少500-800行)
  - 再优化Hooks(预计减少200-300行)
  - 然后提取小型组件(预计减少300-500行)
  - 最后在Dashboard精简到6000行后再拆分Tab
  - 这种方法风险更低,成功率更高

#### 经验 5: 优化的真正目标是可维护性而非行数 ⭐
- **日期**: 2026-01-08
- **场景**: 用户澄清优化目标
- **风险**: 低
- **结果**: 重新定义项目目标和评价标准
- **教训**:
  - **核心目标**: 模块化和可维护性,而不是单纯减少行数
  - **正确做法**: 按功能分类拆分(格式化、搜索、计算等)
  - **评价标准**: 代码清晰度、职责分离、易于理解
  - **自然结果**: 模块化后行数自然下降
  - **避免陷阱**: 不要为了减少行数而过度拆分

#### 经验 6: 系统化提取工具函数效果显著
- **日期**: 2026-01-08
- **场景**: 第二轮纯函数提取
- **风险**: 低
- **结果**: 成功提取16个函数,创建5个utils文件
- **教训**:
  - **分类提取**: 按功能分类(格式化、搜索、聚合、图表、字符串)
  - **职责单一**: 每个utils文件只负责一类功能
  - **逐步验证**: 每个阶段独立测试和提交
  - **实际成果**: Dashboard减少128行,模块化程度显著提升
  - **专业标准**: 符合目标架构定义的专业级别标准

#### 经验 7: 持续模块化优化的完整实践 ⭐
- **日期**: 2026-01-08
- **场景**: 完整的模块化优化会话(6轮优化)
- **风险**: 低
- **结果**: 成功提取21个函数,创建7个utils文件,减少141行
- **教训**:
  - **分阶段推进**: 每轮提取2-5个函数,风险可控
  - **按功能分类**: 7个utils文件各司其职(format, search, aggregation, chart, string, strategy, data-calculation)
  - **独立提交**: 11个Git提交,每个阶段清晰可追溯
  - **类型处理**: 遇到未导出类型使用any,遇到不存在属性简化逻辑
  - **质量优先**: 强调可维护性而非单纯减少行数
  - **实际成果**: Dashboard从7509行减少到7368行(-1.9%),模块化程度达到专业级别

### 失败教训

#### 教训 1: 大爆炸式重构容易导致系统崩溃
- **日期**: 2026-01-06
- **场景**: 尝试一次性拆分 6500+ 行代码
- **结果**: 系统崩溃,功能缺失
- **教训**: 必须小步快跑,每一步都验证

#### 教训 2: Git 历史混乱导致回滚困难
- **日期**: 2026-01-06
- **场景**: 多次修改后发现问题
- **结果**: 难以定位问题提交
- **教训**: 每次优化都要独立提交,提交信息要清晰

#### 教训 3: 高度耦合的代码难以直接拆分
- **日期**: 2026-01-08
- **场景**: 尝试拆分Manage Tab (2086行)
- **结果**: 发现代码高度耦合,暂停拆分
- **教训**:
  - Tab之间共享大量状态,需要传递30+个Props
  - 事件处理器分散在各处,难以整理
  - 类型导入问题(ReviewHint未导出, SPACE在dashboardPrimitives中)
  - 应该先降低耦合度再拆分,而不是直接拆分

#### 教训 4: 及时调整策略比硬推更明智
- **日期**: 2026-01-08  
- **场景**: Tab拆分遇到困难
- **结果**: 及时调整策略,保持项目稳定
- **教训**:
  - 遇到困难时不要硬推,要重新评估
  - 灵活调整策略比坚持错误方向更重要
  - 保持项目清洁,删除临时文件
  - 详细记录决策过程和原因

---

## 🔄 技能升级记录

### v1.4.0 (2026-01-08)
- 📚 新增经验 7: 持续模块化优化的完整实践
- ✅ 完整实战: 6轮优化,21个函数,7个utils文件
- 📊 量化成果: Dashboard减少141行,模块化达到专业级别
- 🎯 质量优先: 强调可维护性而非单纯减少行数
- 💡 最佳实践: 分阶段推进、按功能分类、独立提交、类型安全处理

### v1.3.0 (2026-01-08)
- 📚 新增经验 6: 系统化提取工具函数效果显著
- ✅ 实战成果: 提取16个函数,创建5个utils文件
- 📊 量化成果: Dashboard减少128行,模块化程度显著提升
- 🎯 验证标准: 符合专业级别架构标准
- 💡 最佳实践: 按功能分类、职责单一、逐步验证

### v1.2.0 (2026-01-08)
- ⭐ **重要更新**: 明确优化的真正目标是可维护性而非行数
- 📚 新增经验 5: 优化的真正目标是可维护性而非行数
- 💡 调整评价标准: 从"减少行数"到"模块化程度"
- 📋 完善优化策略: 强调职责分离和代码清晰度
- ✅ 实战验证: 成功提取8个utils函数,创建2个utils文件

### v1.1.0 (2026-01-08)
- 📚 新增经验 3: 代码量评估是拆分前的必要步骤
- 📚 新增经验 4: 渐进式精简优于直接拆分
- ⚠️ 新增教训 3: 高度耦合的代码难以直接拆分
- ⚠️ 新增教训 4: 及时调整策略比硬推更明智
- 💡 完善Tab拆分场景的风险评估
- 📋 添加渐进式精简的具体步骤

### v1.0.0 (2026-01-07)
- ✨ 初始版本
- 📋 定义标准优化流程
- 🛠️ 整合 MCP 工具生态
- 📚 建立经验库框架

### 未来计划
- [ ] 添加更多优化场景
- [ ] 完善经验库
- [ ] 增加性能优化技巧
- [ ] 建立自动化测试流程

---

## 💡 使用建议

1. **每次优化前先阅读本技能文档**
2. **严格遵循标准流程,不要跳步**
3. **遇到问题立即停止,分析原因**
4. **及时更新经验库,积累知识**
5. **定期回顾优化记录,总结规律**

---

## 📞 相关文档

- [📋 UI 迭代技能（插件控制台）](./📋%20UI%20迭代技能（插件控制台）.md)
- [📝 系统升级日志](./📝%20系统升级日志.md)
- [📋 交易员控制台 v5.0 深度分析报告（基线）](./📋%20交易员控制台%20v5.0%20深度分析报告（基线）.md)

---

**最后更新**: 2026-01-07  
**维护者**: Antigravity Agent  
**状态**: 活跃使用中 🟢
