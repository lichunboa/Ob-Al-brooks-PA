# 📋 原生插件迁移-现状审查报告（Dataview 控制台 v5.0 / Core v14.6 FIXED）

日期：2026-01-02

## 1. 结论摘要（给迁移决策用）
- 当前“交易员控制台”并不是纯 Dataview：它是 **Dataview 渲染 + Obsidian 原生事件监听** 的混合体。
- **入口页面**通过 `dv.view(...)` 串联 Core 与多个 View；Core 负责生成 `window.paData`，各 View 只读 `window.paData`。
- “实时监控你改笔记内容”已经在 Core 内实现：通过 `app.vault.on('modify'/'rename'/'delete')` + `metadataCache.on('changed')` 把系统置为 dirty，并触发 Dataview refresh。
- 迁移到原生插件时，最大风险不是 UI，而是“隐式口径”：同一指标在不同模块口径不同（例如胜率：`stats` 用 pnl>0，`coachFocus` 用 outcome）。

## 2. 控制台入口与加载链路
### 2.1 入口文件
- 控制台主页：`🦁 交易员控制台 (Trader Command)5.0.md`

### 2.2 加载顺序（关键）
控制台页面依次执行：
1) `await dv.view("scripts/pa-core")`
2) `await dv.view("scripts/pa-view-today")`
3) `await dv.view("scripts/pa-view-hub-analytics")`
4) `await dv.view("scripts/pa-view-memory")` / `pa-view-course` / `pa-view-playbook` / `pa-view-gallery`
5) `await dv.view("scripts/pa-view-inspector")` / `pa-view-schema` / `pa-view-manager`

含义：
- **Core 一定要最先运行**，否则各 View 读取 `window.paData` 会空。

## 3. Core（scripts/pa-core.js）的职责与关键机制
### 3.1 依赖注入方式
- 使用 Obsidian 运行时的 `app.vault.adapter.basePath` 拼出绝对路径，然后 `require(...)` 加载：
  - `scripts/pa-config.js`（主题/路径/标签/业务参数）
  - `scripts/pa-utils.js`（安全读取与归一化）

这意味着它运行在 Obsidian 的“脚本环境”而不是 Node 服务端。

### 3.2 全局状态（关键耦合）
- `window.paData`：系统单一数据源（SSOT），承载 trades、stats、sr、course、daily、strategyIndex 等。
- `window.__paBuilding`：构建锁，避免递归刷新导致卡死。
- `window.paForceReload`：硬刷新标记。
- `window.paDirty` / `window.paDirtyDaily`：脏标记，避免 TTL 内读缓存看不到更新。

### 3.3 缓存与失效（Smart Cache）
- TTL 来自 `cfg.settings.cacheExpiry`。
- 命中缓存要求：
  - 非 forceReload
  - 非 dirty
  - cacheTs 未过期
  - `window.paData` 的关键字段齐全（tradesAsc、sr.load、sr.fileList、strategyIndex 等）

### 3.4 自动刷新（你说的“实时监控”）
Core 安装 `__paAutoRefreshInstalled` 监听器：
- `app.vault.on('modify'|'rename'|'delete', onModify)`
- `app.metadataCache.on('changed', onModify)`（frontmatter/标签变化更可靠）
- 对相关文件（仅 `.md`，排除 Templates）置 dirty，并 debounce 刷新
- 为避免刷新打断滚动：
  - 追踪用户滚动/键盘意图
  - 仅在控制台页面保留滚动

### 3.5 Dataview 刷新与滚动锁
- `window.paRefreshViews(opts)` 统一触发 Dataview refresh（兼容不同 commandId / dv API）。
- 有一套完整的 scroll capture/lock/restore，专门对抗 Dataview 重建 DOM 导致的“跳顶”。

这部分在原生插件里通常可以删除（因为插件 UI 自己掌控渲染周期），但迁移初期应理解其存在原因：避免“视觉跳动”。

## 4. 数据源与索引口径（交易笔记识别规则的现状）
### 4.1 当前交易笔记识别规则
- 依赖 Dataview 查询：`dv.pages(cfg.tags.trade)`
- 在 `scripts/pa-config.js` 中：`cfg.tags.trade = "#PA/Trade"`
- 排除：路径包含 `Templates/`

换句话说：
- 当前“识别交易笔记”= **打了 #PA/Trade 标签**（不是靠目录/文件名）。

### 4.2 trade schema（核心字段）
Core 在扫描模式为每笔交易构造 tradeItem（摘要）：
- 基础：`id/path/link/name/date/mtime/ctime/type`
- 盈亏：`pnl`（来自 `净利润/net_profit` 或 `net_profit`）
- 复盘/分类：`setup/market_cycle/error/outcome/patterns/strategyName`
- 交易要素：`entry/exit/stop/tf/ticker/dir/order/...` + 多种 *Key 归一化字段
- `reviewHints`：仅生成提示，不改用户笔记

## 5. 统计与胜率口径（现状不一致点）
当前系统里存在至少两套“胜率”口径：
1) `stats.liveWin`：在扫描交易时对 Live 类型，使用 `pnl > 0` 计胜。
2) `coachFocus.winRate`：使用 `outcome` 字段（Win/Loss/Scratch/含中文“止盈/止损/保本”）统计。

迁移到插件时必须先统一口径，否则 UI/报告会“看起来不对”。

## 6. 外部依赖与耦合（迁移风险项）
- Dataview：
  - 渲染依赖（dv.view / dv.el / dv.pages）
  - 索引依赖（交易、课程、策略、日记等都是 dv.pages 查询）
- Tasks 插件：控制台主页里大量 ` ```tasks ` 查询块
- QuickAdd：部分视图按钮触发命令 ID（例如新增交易）
- Spaced Repetition：记忆模块按钮触发命令 ID

迁移建议：
- 原生插件 MVP 期间不要强依赖 QuickAdd/SRS（做可选集成）。
- Tasks 查询可留在 Markdown 页面里，或后续另行替代（不建议在 MVP 一起做）。

## 7. 对原生插件实现的直接启发
你在问题 2 里描述的“原生数据实时监控”是可行的，而且当前系统已经验证了事件源：
- `vault.on('modify'|'rename'|'delete')`
- `metadataCache.on('changed')`

但原生插件会做两件关键变化：
- 不再用 Dataview 的 `dv.pages` 做查询；改为直接从 `metadataCache` / `vault` 构建 TradeIndex。
- 不再需要“Dataview 刷新 + 滚动锁”，改为 store 驱动的 React 渲染。

---

## 8. 下一步（供 spec 初始化使用）
- 明确 MVP 的“交易笔记识别规则”在插件里如何定义：tag 优先 vs 路径优先 vs 混合。
- 统一胜率口径：建议以 `pnl` 为主，`outcome` 为兜底。
- 定义最小字段映射表（i18n key map）：pnl、ticker、outcome、r、setup、market_cycle、tf、dir。
