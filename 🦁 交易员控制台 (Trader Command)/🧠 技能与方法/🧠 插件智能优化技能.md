# 🧠 插件智能优化技能库

> **目标**: 使用 MCP 工具生态安全、渐进式地优化和重构 Obsidian 插件代码  
> **版本**: v2.0.0  
> **创建**: 2026-01-07  
> **更新**: 2026-01-11  
> **维护**: 持续更新

---

## 📚 版本说明

**v2.0 更新内容**:
- ✅ 保留所有核心方法论和标准流程
- ✅ 将具体项目经验提炼为通用优化模式
- ✅ 添加到详细历史记录的链接
- ✅ 移除过时的项目状态描述

**v1.0 完整记录**: [存档/🧠 插件智能优化技能-v1.0-完整记录.md](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md) (2,073行完整历史)

---

## 📋 技能概述

这是一个基于 MCP 工具生态的智能代码优化技能,用于安全、渐进式地优化和重构 Obsidian 插件代码。

**核心理念**:
- 🧠 **智能分析** - 使用 AI 工具深度理解代码,而非机械化分析
- 🛡️ **安全优先** - 每一步都可回滚,绝不破坏现有功能
- 📈 **渐进式** - 小步快跑,持续改进
- 💾 **经验积累** - 记录每次优化,建立知识图谱

---

## 🛠️ 工具生态

### 核心工具

| 工具 | 用途 | 使用场景 |
|------|------|----------|
| **sequential-thinking** | 深度分析和推理 | 分析复杂问题、评估风险、设计方案 |
| **serena** | 代码语义理解 | 分析代码结构、识别重复模式、理解依赖关系 |
| **context7** | 最佳实践查询 | 查询官方文档、框架最佳实践、版本特定实现 |
| **morphllm** | 模式化重构 | 批量代码转换、统一代码风格、自动化重构 |
| **neo4j-memory** | 经验沉淀 | 记录优化决策、建立知识图谱、避免重复犯错 |

### 辅助工具

| 工具 | 用途 |
|------|------|
| **git** | 版本控制、分支管理、回滚 |
| **npm** | 构建测试、依赖管理 |

---

## 🎯 标准优化流程

### 流程图

```
┌─────────────────────────────────────────────────────────┐
│                    优化任务开始                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 1. 思考 (sequential-thinking)                            │
│    - 分析要优化的代码                                     │
│    - 评估风险和影响范围                                   │
│    - 设计优化方案                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 2. 分析 (serena)                                         │
│    - 理解代码结构和依赖关系                               │
│    - 识别重复代码模式                                     │
│    - 分析模块耦合度                                       │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 3. 查询 (context7)                                       │
│    - 查询官方最佳实践                                     │
│    - 确认实现方式                                         │
│    - 避免常见陷阱                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 4. 创建安全点                                            │
│    - git checkout -b backup-$(date)                     │
│    - 记录当前状态                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 5. 重构 (morphllm)                                       │
│    - 批量代码转换                                         │
│    - 保持代码一致性                                       │
│    - 减少手工错误                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 6. 验证                                                  │
│    - npm run build (构建测试)                            │
│    - 手动功能测试                                         │
│    - 性能测试(如需要)                                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
                 验证通过?
                     │
        ┌────────────┴────────────┐
        │                         │
       是                         否
        │                         │
        ▼                         ▼
┌───────────────┐        ┌─────────────────┐
│ 7. 提交变更    │        │ 8. 回滚并分析    │
│ - git commit  │        │ - git reset     │
│ - 记录成功    │        │ - 分析失败原因   │
└───────┬───────┘        └────────┬────────┘
        │                         │
        │                         │
        └────────────┬────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ 9. 记录 (neo4j-memory)                                   │
│    - 记录优化内容和原因                                   │
│    - 记录经验教训                                         │
│    - 更新知识图谱                                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    优化任务完成                          │
└─────────────────────────────────────────────────────────┘
```

---

## 📖 详细步骤说明

### 步骤 1: 思考 (sequential-thinking)

**目标**: 深度理解问题,设计安全的优化方案

**操作**:
```markdown
使用 sequential-thinking 分析:

1. **问题定义**
   - 当前代码有什么问题?
   - 为什么需要优化?
   - 优化的目标是什么?

2. **影响范围分析**
   - 哪些模块会受影响?
   - 有哪些依赖关系?
   - 可能的副作用是什么?

3. **风险评估**
   - 风险等级: 低/中/高
   - 失败的可能性
   - 回滚的难度

4. **方案设计**
   - 优化的具体步骤
   - 每一步的验证方式
   - 备选方案
```

**输出**: 优化方案文档

---

### 步骤 2: 分析 (serena)

**目标**: 语义级别理解代码结构

**操作**:
```bash
# 1. 激活 serena 项目环境
mcp__serena__activate_project

# 2. 分析代码符号和引用
# 使用 serena 的代码理解能力

# 3. 识别重复代码模式
# 4. 分析模块依赖关系
```

**输出**: 
- 函数调用图
- 重复代码列表
- 依赖关系图

---

### 步骤 3: 查询 (context7)

**目标**: 确保使用官方推荐的最佳实践

**操作**:
```markdown
使用 context7 查询:

1. **框架最佳实践**
   - React Hooks 使用规范
   - TypeScript 类型优化
   - Obsidian 插件 API 最佳实践

2. **性能优化技巧**
   - 组件优化
   - 状态管理
   - 渲染优化

3. **常见陷阱**
   - 避免的反模式
   - 已知问题
```

**输出**: 最佳实践文档

---

### 步骤 4: 创建安全点

**目标**: 确保可以随时回滚

**操作**:
```bash
# 创建备份分支
git checkout -b backup-$(date +%Y%m%d-%H%M%S)

# 切换回工作分支
git checkout feature/smart-optimization

# 记录当前状态
git log -1 --oneline
```

---

### 步骤 5: 重构 (morphllm)

**目标**: 批量、一致地进行代码转换

**操作**:
```markdown
使用 morphllm 进行:

1. **批量重命名**
   - 统一命名规范
   - 保持一致性

2. **代码提取**
   - 提取重复逻辑
   - 创建公共函数

3. **模式转换**
   - 统一代码风格
   - 应用最佳实践
```

---

### 步骤 6: 验证

**目标**: 确保优化没有破坏功能

**操作**:
```bash
# 1. 构建测试
npm run build

# 2. 类型检查
npm run type-check

# 3. 代码规范检查
npm run lint
```

**手动测试清单**:
- [ ] 所有Tab显示正常
- [ ] 数据统计正确
- [ ] 交互功能正常
- [ ] 无控制台错误

---

### 步骤 7: 提交变更

**目标**: 记录成功的优化

**操作**:
```bash
# 提交变更
git add .
git commit -m "refactor: [描述优化内容]

- 优化内容 1
- 优化内容 2
- 优化内容 3

风险等级: 低
验证: 构建通过 + 功能测试通过"
```

---

### 步骤 8: 回滚并分析

**目标**: 从失败中学习

**操作**:
```bash
# 立即回滚
git reset --hard HEAD~1

# 或切换到备份分支
git checkout backup-20260107-161500
```

**失败分析**:
```markdown
使用 sequential-thinking 分析:

1. **失败原因**
   - 技术原因
   - 设计缺陷
   - 遗漏的依赖

2. **经验教训**
   - 下次如何避免
   - 需要补充的知识

3. **改进方案**
   - 调整优化策略
   - 增加验证步骤
```

---

### 步骤 9: 记录 (neo4j-memory)

**目标**: 积累优化经验,建立知识图谱

**操作**:
```markdown
使用 neo4j-memory 记录:

1. **优化记录**
   - 优化内容: [描述]
   - 优化原因: [原因]
   - 风险等级: 低/中/高
   - 结果: 成功/失败
   - 耗时: [时间]

2. **经验教训**
   - 成功经验: [描述]
   - 失败教训: [描述]
   - 最佳实践: [描述]

3. **知识关联**
   - 相关优化: [链接]
   - 相关文档: [链接]
   - 相关问题: [链接]
```

---

## 🎓 常见优化场景

### 场景 1: 提取纯函数

**适用情况**: 组件中有大量计算逻辑

**风险等级**: 🟢 低

**步骤**:
1. 使用 serena 识别纯函数
2. 使用 sequential-thinking 评估提取风险
3. 创建 `src/utils/` 目录
4. 使用 morphllm 批量提取
5. 验证功能
6. 记录到 neo4j-memory

**示例**:
```typescript
// 提取前: Dashboard.tsx
const winRate = trades.filter(t => t.outcome === 'win').length / trades.length;

// 提取后: src/utils/trade-calculations.ts
export function calculateWinRate(trades: Trade[]): number {
  if (trades.length === 0) return 0;
  return trades.filter(t => t.outcome === 'win').length / trades.length;
}
```

**最佳实践**:
- ✅ 提取: 复杂逻辑、可复用函数、纯函数
- ❌ 不提取: 简单包装、UI回调、一次性逻辑
- 🎯 按功能分类: format、search、calculation、chart等

---

### 场景 2: 提取自定义 Hooks

**适用情况**: 组件中有复杂的状态管理和副作用

**风险等级**: 🟡 中

**步骤**:
1. 使用 context7 查询 React Hooks 最佳实践
2. 使用 sequential-thinking 设计 Hook 接口
3. 创建 `src/hooks/` 目录
4. 逐个提取数据加载逻辑
5. 每个 Hook 独立测试
6. 记录到 neo4j-memory

**示例**:
```typescript
// 提取前: Dashboard.tsx
useEffect(() => {
  const loadData = async () => {
    const trades = await tradeIndex.getAllTrades();
    setTrades(trades);
  };
  loadData();
}, []);

// 提取后: src/hooks/useDashboardData.ts
export function useDashboardData() {
  const [trades, setTrades] = useState<Trade[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const trades = await tradeIndex.getAllTrades();
      setTrades(trades);
      setLoading(false);
    };
    loadData();
  }, []);
  
  return { trades, loading };
}
```

---

### 场景 3: 拆分大型组件

**适用情况**: 组件超过 1000 行

**风险等级**: 🔴 高

**前置评估** (必须先做!):
1. **代码量分析**: 统计各部分的行数
   - 超过2000行: 极高风险,建议先精简
   - 1000-2000行: 高风险,需要详细规划
   - 500-1000行: 中等风险,可以尝试
   - 小于500行: 低风险

2. **耦合度分析**: 评估代码依赖关系
   - Props数量: 超过20个表示高度耦合
   - 共享状态: 多个部分共享状态增加难度
   - 事件处理: 分散的事件处理器难以整理

3. **类型依赖**: 检查类型导入和导出
   - 未导出的类型会导致编译错误
   - 需要提前整理类型定义

**渐进式方法** (推荐):
1. **先精简再拆分**:
   - 提取纯函数到utils (减少500-800行)
   - 优化Hooks (减少200-300行)
   - 提取小型组件 (减少300-500行)
   - 等组件精简到合理大小后再拆分

2. **小步拆分**:
   - 从最小的、耦合最少的部分开始
   - 每次拆分后立即测试
   - 保持可回滚

**直接拆分步骤** (仅用于低耦合组件):
1. 使用 serena 分析组件边界
2. 使用 sequential-thinking 设计拆分方案
3. 使用 context7 查询组件拆分最佳实践
4. 创建子组件目录
5. 逐个拆分,每次拆分后立即测试
6. 记录到 neo4j-memory

**注意事项**:
- ⚠️ 超过1000行的代码块很难一次性拆分
- ⚠️ 每次只拆分一个子组件
- ⚠️ 保持 Props 接口清晰 (建议少于15个)
- ⚠️ 避免过度拆分
- ⚠️ 遇到困难及时调整策略,不要硬推
- ⚠️ 保持项目清洁,删除临时文件

---

### 场景 4: 移除重复代码

**适用情况**: 发现多处相同或相似的代码

**风险等级**: 🟡 中

**步骤**:
1. 使用 serena 识别重复代码模式
2. 使用 sequential-thinking 评估合并风险
3. 提取为公共函数或组件
4. 使用 morphllm 批量替换
5. 验证所有使用场景
6. 记录到 neo4j-memory

---

## 📊 优化指标

### 代码质量指标

| 指标 | 目标 | 测量方法 |
|------|------|----------|
| 平均函数长度 | < 50行 | 代码分析工具 |
| 重复代码率 | < 5% | 代码分析工具 |
| 循环依赖数 | 0 | 依赖分析 |
| 组件大小 | < 500行 | 文件行数统计 |

### 性能指标

| 指标 | 目标 | 测量方法 |
|------|------|----------|
| 构建时间 | 减少20% | `time npm run build` |
| 插件加载时间 | < 1s | 性能分析 |
| 内存占用 | < 50MB | 性能分析 |

---

## 🛡️ 风险控制清单

### 优化前检查

- [ ] 已创建 LTS 标签
- [ ] 已创建备份分支
- [ ] 已使用 sequential-thinking 评估风险
- [ ] 已使用 serena 分析影响范围
- [ ] 已查询相关最佳实践

### 优化中检查

- [ ] 每次修改后立即构建测试
- [ ] 保持小步快跑
- [ ] 遇到问题立即停止
- [ ] 记录每一步的变更

### 优化后检查

- [ ] 构建测试通过
- [ ] 功能测试通过
- [ ] 性能没有退化
- [ ] 已记录到 neo4j-memory
- [ ] 已更新文档

---

## 💡 优化模式库

### 模式1: 纯函数提取模式

**核心原则**: 无副作用、输入输出确定

**适用场景**:
- 计算逻辑 (如统计、格式化)
- 数据转换 (如过滤、映射)
- 工具函数 (如日期处理、字符串处理)

**实施步骤**:
1. 识别纯函数候选
2. 按功能分类创建utils文件
3. 逐个提取并测试
4. 更新导入语句

**成功标志**:
- ✅ 函数可独立测试
- ✅ 代码可复用
- ✅ 职责单一明确

**详细案例**: [v1.0 - 经验6](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-6-系统化提取工具函数效果显著)

---

### 模式2: Hooks提取模式

**核心原则**: 封装状态管理和副作用

**适用场景**:
- 数据加载逻辑
- 复杂状态管理
- 副作用处理

**实施步骤**:
1. 设计Hook接口 (输入/输出)
2. 提取状态和副作用
3. 独立测试Hook
4. 在组件中使用

**成功标志**:
- ✅ Hook可复用
- ✅ 组件逻辑简化
- ✅ 状态管理清晰

---

### 模式3: JSX结构精确分析模式

**核心原则**: 使用工具而不是猜测

**适用场景**:
- 大型JSX文件中的组件提取
- 复杂嵌套结构的重构

**实施步骤**:
1. 使用`grep_search`查找标签
2. 使用`view_file`查看完整代码
3. 绘制结构图，标注嵌套层次
4. 使用`replace_file_content`精确替换

**关键技能**:
- ❌ 永远不要用Python脚本操作JSX
- ✅ 使用`TargetContent`精确匹配
- ✅ 保留外层结构，只替换必要部分
- ✅ 每次修改后立即验证

**详细案例**: [v1.0 - 经验8](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-8-todaykpicard组件集成成功)

---

### 模式4: 渐进式精简模式

**核心原则**: 先精简再拆分

**适用场景**:
- 超大型组件 (>2000行)
- 高度耦合的代码

**实施步骤**:
1. 第一轮: 提取纯函数 (减少500-800行)
2. 第二轮: 优化Hooks (减少200-300行)
3. 第三轮: 提取小型组件 (减少300-500行)
4. 第四轮: 拆分Tab/模块

**成功标志**:
- ✅ 每轮风险可控
- ✅ 逐步降低耦合度
- ✅ 最终达到目标架构

**详细案例**: [v1.0 - 经验4](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-4-渐进式精简优于直接拆分)

---

## ⚠️ 常见陷阱

### 陷阱1: 大爆炸式重构 🔴

**描述**: 尝试一次性拆分大量代码

**后果**: 系统崩溃，功能缺失，难以回滚

**避免方法**:
- 小步快跑，每次只改一个模块
- 每步立即测试
- 保持可回滚

**详见**: [v1.0 - 教训1](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-1-大爆炸式重构容易导致系统崩溃)

---

### 陷阱2: Python脚本操作JSX ⚠️

**描述**: 使用Python脚本按行号删除或修改JSX代码

**后果**: 破坏JSX Fragment结构，导致编译失败

**避免方法**:
- ❌ 永远不要用Python脚本操作JSX
- ✅ 使用`replace_file_content`工具
- ✅ 通过`TargetContent`精确匹配内容
- ✅ 深度分析JSX结构

**详见**: [v1.0 - 教训5](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-5-使用python脚本操作jsx代码极易破坏结构)

---

### 陷阱3: 高度耦合代码直接拆分 🔴

**描述**: 在代码高度耦合时直接拆分组件

**后果**: 需要传递30+个Props，拆分失败

**避免方法**:
- 先降低耦合度 (提取共享状态到Context)
- 再拆分组件
- 评估Props数量 (超过15个需要重新设计)

**详见**: [v1.0 - 教训3](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-3-高度耦合的代码难以直接拆分)

---

### 陷阱4: Git历史混乱 🟡

**描述**: 多次修改后发现问题，难以定位问题提交

**后果**: 难以回滚，浪费时间

**避免方法**:
- 每次优化都要独立提交
- 提交信息要清晰
- 使用有意义的分支名

---

### 陷阱5: 忽视类型安全 🟡

**描述**: 使用非空断言`!`或`any`类型

**后果**: 运行时错误，难以调试

**避免方法**:
- ✅ 使用可选链 `?.`
- ✅ 使用类型守卫
- ❌ 避免非空断言 `!`
- ❌ 避免`any`类型

**示例**:
```typescript
// ❌ 错误
bucketed.get(g)!.push(key);

// ✅ 正确
const bucket = bucketed.get(g);
if (bucket) {
  bucket.push(key);
}
```

---

## 🎯 核心原则

### 原则1: 优化目标是可维护性而非行数 ⭐⭐⭐⭐⭐

**核心观点**:
- 主要目的: 模块化和可维护性
- 次要目标: 减少行数 (作为模块化的自然结果)

**正确做法**:
- ✅ 按功能分类拆分 (格式化、搜索、计算等)
- ✅ 职责分离，每个文件功能单一
- ✅ 代码清晰度、易于理解

**错误做法**:
- ❌ 为了减少行数而过度拆分
- ❌ 忽视代码的逻辑关联性

**详见**: [v1.0 - 经验5](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-5-优化的真正目标是可维护性而非行数)

---

### 原则2: 理解真正的架构目标 ⭐⭐⭐⭐⭐

**关键洞察**:
- 目标架构文档是北极星
- 中间里程碑 ≠ 最终目标
- 专业结构的标准要明确

**实施建议**:
1. 认真阅读目标架构文档
2. 理解每个模块的职责
3. 制定完整的实施计划
4. 定期检查是否偏离目标

**详见**: [v1.0 - 经验10](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-10-目标认知更新)

---

### 原则3: 小步快跑，持续改进

**实施方法**:
- 每次只改一个模块
- 每步立即测试和提交
- 保持随时可回滚

**成功标志**:
- Git历史清晰可追溯
- 每个提交都是稳定状态
- 遇到问题可快速回滚

---

## 📚 实战经验索引

本技能库从大量实战中提炼而来。详细的经验记录请查看:

### 完整历史记录
- [v1.0 完整记录](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md) (2,073行)
- [Phase 1-12 详细记录](./存档/📋%20插件优化项目-主任务列表.md) (1,962行)

### 成功经验精选
1. [经验1: 纯函数提取是最安全的重构方式](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-1)
2. [经验5: 优化目标是可维护性而非行数](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-5) ⭐⭐⭐⭐⭐
3. [经验6: 系统化提取工具函数效果显著](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-6)
4. [经验8: JSX结构精确分析](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-8) ⭐⭐⭐
5. [经验9: 大型组件提取](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-9) ⭐⭐⭐⭐
6. [经验10: 理解真正的架构目标](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#经验-10) ⭐⭐⭐⭐⭐

### 失败教训精选
1. [教训1: 大爆炸式重构容易崩溃](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-1) 🔴
2. [教训3: 高度耦合代码难以直接拆分](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-3) 🔴
3. [教训5: Python脚本操作JSX极易破坏结构](./存档/🧠%20插件智能优化技能-v1.0-完整记录.md#教训-5) ⚠️

### 项目实战成果
- Dashboard.tsx: 7,624行 → 3,510行 (-54%)
- 创建11个utils文件 (37个纯函数)
- 创建5个自定义Hooks
- 拆分4个Tab组件
- 提取14个子组件

---

## 🔄 持续更新

本技能库会随着新的优化实践持续更新。

**更新原则**:
- 保留核心方法论
- 提炼新的优化模式
- 记录新的陷阱和教训
- 链接到详细历史记录

**贡献方式**:
- 记录每次优化的经验
- 更新优化模式库
- 补充常见陷阱
- 完善检查清单

---

**版本**: v2.0.0  
**维护**: Antigravity Agent  
**更新**: 2026-01-11
